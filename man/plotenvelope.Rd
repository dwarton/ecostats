% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plotenvelope.R
\name{plotenvelope}
\alias{plotenvelope}
\title{Diagnostic Plots for a Fitted Object with Simulation Envelopes}
\usage{
plotenvelope(
  y,
  which = 1:3,
  main = c("Residuals vs Fitted Values", "Normal Quantile Plot", "Scale-Location Plot"),
  xlab = c("Fitted values", "Theoretical Quantiles", "Fitted Values"),
  ylab = c("Residuals", "Residuals", expression(sqrt("|Residuals|"))),
  n.sim = 199,
  conf.level = 0.95,
  type = "st",
  transform = NULL,
  sim.method = "norm",
  col = par("col"),
  smooth.col = "black",
  line.col = "darkolivegreen3",
  envelope.col = adjustcolor(line.col, 0.1),
  plot.it = TRUE,
  ...
)
}
\arguments{
\item{y}{is \emph{any} object that responds to the \code{residuals} and \code{simulate}
functions. The function was designed with models in mind whose residuals would be 
approximately normally distributed if the model were correct.}

\item{which}{which diagnostic plots to construct: 1=residual vs fits with a smoother,
2=normal quantile plot, 3=scale-location plot with smoother. These are the first three
options in \code{\link{plot.lm}} and borrow heavily from that code.}

\item{main}{the plot title (if a plot is produced). A vector of three titles, one for each plot.
If only one value is given that will be used for all plots.}

\item{xlab}{\code{x} axis label (if a plot is produced). A vector of three labels, one for each plot.
If only one value is given that will be used for all plots.}

\item{ylab}{\code{y} axis label (if a plot is produced). A vector of three labels, one for each plot.
If only one value is given that will be used for all plots.}

\item{n.sim}{the number of simulated sets of residuals to be generated, to which
the observed residuals will be compared. The default is 199 datasets, you should bump it up to
something more like 999 for publication (but note that would take about five times longer to run).}

\item{conf.level}{the confidence level to use in constructing the envelope.}

\item{type}{the type of global envelope to construct, see 
\code{\link[GET]{global_envelope_test}} for details. Defaults \code{"st"} uses 
studentized envelope tests to protect for unequal variance, which has performed well
in \code{qqnorm} simulations.}

\item{transform}{a character vector pointing to a function that should be applied to both
axes of the normal quantile plot. The most common use is to set \code{transform="pnorm"}
for a PP-plot.}

\item{sim.method}{How should residuals be simulated? The default \code{"norm"} simulates from a normal
distribution, matching means and variances (and covariances for multivariate responses) to the observed residuals.
The \code{"stand.norm"} option sets means to zero and variances to one, which is appropriate when residuals
should be standard normal when assumptions are satisfied (as when using \code{residuals.manyglm} from the \code{mvabund}
package, for example). The \code{"refit"} option constructs new responses (via \code{\link{simulate}}),
refits the model (via \code{\link{update}}), then recomputes residuals, often known as a \emph{parametric bootstrap}.
This is computationally intensive but gives a more robust answer. This is the only suitable option if
residuals are not normal when assumptions are satisfied (like when using \code{\link[stats]{glm}}).}

\item{col}{color of points}

\item{smooth.col}{color of smoother in residual vs fits and scale-location plots}

\item{line.col}{color of line on each plot, following the expected trend when assumptions
are satisfied. Defaults to "darkolivegreen". Because it's cool.}

\item{envelope.col}{color of the global envelope around the expected trend. The smoother
should always stay within this (because it will do for a proportion \code{conf.level} of 
datasets satisfying model assumptions). Color defaults to a transparent version of \code{line.col}.}

\item{plot.it}{logical. Should the result be plotted? If not, a list of analysis outputs
is returned, see \emph{Value}.}

\item{...}{further arguments sent through to \code{plot}}
}
\value{
up to three diagnostic plots with simulation envelopes are returned, and additionally a list of 
three objects used in plotting.
}
\description{
Produces diagnostic plots of a \emph{fitted model} \code{y}, and
adds global envelopes constructed by simulating new residuals to
provide guidance as to whether departures from expected trends are
large relative to sampling variation if the fitted model were
correct. Global envelopes are constructed using the
\code{GET} package for simultaneous control of error rates over the
whole plot, and residuals can wither be simulated from the true model
(computationally intensive) or from the standard normal (not always
a smart move). Diagnostic plots presented are residual vs fits,
a normal quantile plot, and a scale-location plot.
}
\details{
A challenge when interpreting diagnostic plots is understanding the extent to which
deviations from the expected pattern could be due to random noise (sampling variation)
rather than actual assumption violations. This function is intended to assess this, 
by simulating multiple realizations of residuals (and fitted values) in situations where 
assumptions are satisfied, and plotting a simulation envelope around these at level \code{conf.level}.

This function can take data (univariate or multivariate) and check for (multivariate)
normality, or it can take a fitted model and use qq plots to interrogate residuals and
see if they are behaving as we would expect them to if the model were true. As long as 
the fitted model accepts \code{\link{simulate}}, \code{\link{residuals}} and 
\code{\link{predict}} it should be fine.

The \code{which} argument determines which plots are constructed, out of a residual vs fits
plot, a normal quantile plot, and a scale-location plot. These are the first three options 
in \code{link{plot.lm}}, code was borrowed from there in constructing these plots.

Envelopes are generated using a method controlled by \code{sim.method}.
The default (\code{sim.method="norm"}) is to simulate new (multivariate) normal residuals repeatedly and hence these
can be used to assess whether trends in the observed data depart from what would be expected
for independent (multivariate) normal residuals. If residuals are expected to be standard
normal, a more refined check is to simulate from the standard normal using (\code{sim.method="stand.norm"}).
This would for example be appropriate when diagnosing a \code{\link[mvabund]{manyglm}} object, since
Dun-Smyth residuals are approximately standard normal when assumptions are satisfied.  
A more rigorous but computationally intensive approach (\code{sim.method="refit"}) is to use a 
\emph{parametric bootstrap} approach: simulate new responses from the fitted model, refit 
the model and recompute residuals and fitted values. This directly assesses whether trends 
in observed trends depart from what would be expected if the fitted model were correct, 
without any further assumptions. For complex models or large datasets this would however be super-slow.

Note that for multivariate normal data, \code{\link{cresiduals}} and \code{\link{cpredict}} 
are used to construct residuals and fitted values (respectively) from the \emph{full conditional models}
(that is, models constructed by regressing each response against all other responses
together with predictors). This is done because full conditionals are diagnostic of joint 
distributions, so \emph{any} violation of multivariate normality is expressed as a violation of 
linear model assumptions on full conditionals. By default, results for all responses are
overlaid on a single plot, but separate plots for each response can be constructed using
\code{overlay=FALSE}.

Simulation envelopes are global, constructed using the \code{\link[GET]{GET-package}}, meaning that
(for example) a 95% global envelope on a QQ plot should contain \emph{all} residuals for 95% of datasets
for which assumptions are actually satisfied. So if \emph{any} data points lie outside the
envelope we have evidence that assumptions of the fitted model are not satisfied. 
For residual vs fits and scale-location plots, global envelopes are constructed for
the \emph{smoother}, not for the data, hence we are looking to see if the smoother
is wholly contained within the envelope. The smoother is constructed using \code{link[mgcv]{gam}}.

The simulated data and subsequent analysis are also used to obtain a \emph{P}-value 
for the test that model assumptions are correct, for each plot. This test uses a 
"parametric bootstrap" test (for \code{do.fit=TRUE}), and tests if sample residuals or their smoothers
are unusually far from the values expected of them if model assumptions were satisfied. For details see
\code{\link[GET]{global_envelope_test}}.
}
\examples{
# fit a multivariate linear model to the iris dataset:
data(iris)
Y = with(iris, cbind(Sepal.Length,Sepal.Width,Petal.Length,Petal.Width))
iris.mlm=lm(Y~Species,data=iris)
# check normality assumption:
plotenvelope(iris.mlm,n.sim=199)

}
\seealso{
\code{\link{cpredict}}, \code{\link{cresiduals}}, \code{\link{qqenvelope}}
}
\author{
David Warton <david.warton@unsw.edu.au>
}
